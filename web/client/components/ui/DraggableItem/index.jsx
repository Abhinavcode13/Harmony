// @flow
import * as React from 'react';
import Draggable from 'react-draggable';

import DraggableChild from 'components/ui/DraggableItem/internal/DraggableChild';
import autobind from 'decorators/autobind';
import { noop } from 'util/util';
import type { StyleObject } from 'types/jsCore';

type Position = {
  x: number,
  y: number,
};

// Signal provided handler should return to instruct how the new drag position
// should be preserved.
//   - `STORE | void`: Store the drag position immediately.
//   - `IGNORE`: Ignore the latest drag position do not overwrite the previous
//               position.
//   - `RESET`: Reset the drag position to 0,0 immediately.
export type DragEventSignal = 'STORE' | 'IGNORE' | 'RESET' | void;
export const DRAG_SIGNAL: { [DragEventSignal]: DragEventSignal } = {
  STORE: 'STORE',
  IGNORE: 'IGNORE',
  RESET: 'RESET',
};

// Data provided by react-draggable in the event handler callback.
// TODO(stephen): Get this from react-draggable eventually. Their current types
// do not pass flow validation though.
export type DraggableData = {
  deltaX: number,
  deltaY: number,
  lastX: number,
  lastY: number,
  node: HTMLElement,
} & Position;

type DraggableEventHandler<T> = (
  e: SyntheticEvent<HTMLDivElement>,
  data: DraggableData,
  extraEventData: T,
) => DragEventSignal;

type DraggableProps<T> = {
  /**
   * Called while the component is being dragged.
   */
  onDrag: DraggableEventHandler<T>,

  /**
   * Called when the component first starts being dragged by the user.
   */
  onDragEnd: DraggableEventHandler<T>,

  /**
   * Called when the user releases the item and dragging is stopped.
   */
  onDragStart: DraggableEventHandler<T>,
};

type Props<T> = {
  children: React.Element<React.ElementType>,
  disableDrag: boolean,

  /**
   * Restrict the bounding area this item can be dragged within. If not
   * provided, the item can be dragged anywhere on the page.
   * - `void`: Do not restrict dragging to any boundary.
   * - `parent`: Restrict the movement of the element to only within the
   *             element's offsetParent (the nearest node with position
   *             relative/absolute).
   * - `string`: Restrict movement of the element to only move within elements
   *             that match the CSS selector supplied.
   * - `{ bottom: number, left: number, right: number, top: number }`:
   *             Relative bounding box to restrict the movement of the element
   *             within. These indicate how far in each direction the element
   *             can move.
   */
  dragMovementBounds:
    | void
    | 'parent'
    | string
    | { bottom: number, left: number, right: number, top: number },

  /**
   * Optional css selector to limit the elements that dragging can be initiated
   * on to only those that match the selector.
   */
  dragRestrictionSelector: string,

  /**
   * Extra data to pass into the event callbacks.
   */
  extraEventData: T,
  style: StyleObject,
} & DraggableProps<T>;

type State = {
  position: Position,
};

// Store the timestamp of the latest "drag end" event so we can suppress onClick
// events that might be generated by the browser at the same time.
let LAST_DRAG_END_TIMESTAMP = 0;

/**
 * The DraggableItem is a flexibile UI component that can make any element
 * draggable.
 */
export default class DraggableItem<T> extends React.PureComponent<
  Props<T>,
  State,
> {
  static defaultProps = {
    disableDrag: false,
    dragMovementBounds: undefined,
    dragRestrictionSelector: '',
    extraEventData: undefined,
    onDrag: noop,
    onDragEnd: noop,
    onDragStart: noop,
    style: {},
  };

  state: State = {
    position: { x: 0, y: 0 },
  };

  updatePosition({ x, y }: Position) {
    this.setState({ position: { x, y } });
  }

  // Convert our internal event signals into a react-draggable interpretable
  // event response. react-draggable interprets `undefined` as store and
  // `false` as ignore the event.
  callEventHandler(
    handler: DraggableEventHandler<T>,
    e: SyntheticEvent<HTMLDivElement>,
    data: DraggableData,
  ): void | false {
    const { disableDrag, extraEventData } = this.props;

    // NOTE(stephen): Need to check the disableDrag property here since
    // react-draggable will not re-check the "disabled" prop if dragging is
    // in progress.
    if (disableDrag) {
      return false;
    }

    const signal = handler(e, data, extraEventData);
    if (signal === DRAG_SIGNAL.STORE || signal === undefined) {
      this.updatePosition(data);
      return undefined;
    }

    if (signal === DRAG_SIGNAL.IGNORE) {
      return false;
    }

    if (signal === DRAG_SIGNAL.RESET) {
      this.updatePosition({ x: 0, y: 0 });
      return undefined;
    }

    return undefined;
  }

  @autobind
  onDrag(e: SyntheticEvent<HTMLDivElement>, data: DraggableData): void | false {
    return this.callEventHandler(this.props.onDrag, e, data);
  }

  @autobind
  onDragStart(
    e: SyntheticEvent<HTMLDivElement>,
    data: DraggableData,
  ): void | false {
    return this.callEventHandler(this.props.onDragStart, e, data);
  }

  @autobind
  onDragEnd(
    e: SyntheticEvent<HTMLDivElement>,
    data: DraggableData,
  ): void | false {
    LAST_DRAG_END_TIMESTAMP = e.timeStamp;
    return this.callEventHandler(this.props.onDragEnd, e, data);
  }

  @autobind
  onClickCapture(e: SyntheticEvent<HTMLDivElement>) {
    // Prevent click events from propagating down to child elements if the click
    // is triggered at the same time that dragging ends.
    if (e.timeStamp === LAST_DRAG_END_TIMESTAMP) {
      e.stopPropagation();
      e.preventDefault();
      return false;
    }

    return undefined;
  }

  render() {
    const {
      children,
      disableDrag,
      dragMovementBounds,
      dragRestrictionSelector,
      style,
    } = this.props;

    const className =
      dragRestrictionSelector.length === 0
        ? 'ui-draggable-item ui-draggable-item--fully-draggable'
        : 'ui-draggable-item';
    return (
      <Draggable
        axis="y"
        bounds={dragMovementBounds}
        disabled={disableDrag}
        handle={dragRestrictionSelector}
        onDrag={this.onDrag}
        onStop={this.onDragEnd}
        onStart={this.onDragStart}
        position={this.state.position}
      >
        <DraggableChild
          additionalStyle={style}
          className={className}
          onClickCapture={this.onClickCapture}
        >
          {children}
        </DraggableChild>
      </Draggable>
    );
  }
}
