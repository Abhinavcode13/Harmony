from future import standard_library

standard_library.install_aliases()
from builtins import object
from datetime import datetime
from http.client import NO_CONTENT

from flask import g, url_for, current_app
from flask_user import current_user
from flask_potion import fields
from flask_potion.contrib.alchemy import fields as alchemy_fields
from flask_potion.routes import Route, ItemRoute, Relation
from flask_potion.signals import after_create, before_update
from flask_potion.instances import Instances
from werkzeug.exceptions import Unauthorized

from config.dashboard_base import EMPTY_SPECIFICATION_AS_JSON
from models.alchemy.dashboard import Dashboard, DashboardUserMetadata
from models.alchemy.user import User
from models.alchemy.history import HistoryRecord

from web.server.api.model_schemas import USERNAME_SCHEMA, generate_history_record_schema
from web.server.api.api_models import PrincipalResource
from web.server.data.data_access import Transaction
from web.server.security.permissions import principals
from web.server.potion.filters import UserFilter
from web.server.routes.views.authorization import (
    AuthorizedOperation,
    authorization_required,
)
from web.server.routes.views.dashboard import (
    _add_visualization,
    api_bulk_transfer_dashboard_ownership,
    api_transfer_dashboard_ownership,
    DashboardManager,
    format_and_upgrade_specification,
    get_dashboard_title,
    get_or_create_metadata,
    lookup_author,
)
from web.server.util.util import EMAIL_PATTERN, as_dictionary
from web.server.errors import NotificationError

# TODO(vedant) - Allow users to change their Dashboard Slugs via the Settings
# Modal. Once this is done, we will restrict the ability to use whitespaces
# in dashboard slugs.
DASHBOARD_SLUG_PATTERN = r'(^[a-zA-Z0-9-_ ]*)$'

# The schema for the `selections` object that is POSTed to the `visualization` API. This
# essentially represents the selections generated by the Query Tool. We are not specifying
# A detailed schema for this object as it is not really necessary at this stage since the
# selections object is in flux and if the structure ever changes without this schema definition
# being altered, any APIs that reference this schema will reject the client request since it
# will not match the defined schema.
SELECTIONS_SCHEMA = fields.Custom(
    fields.Any(),
    description='The selections object containing the query to be added to a dashboard.',
)

# The schema for the `query_result_spec` object that is POSTed to the
# `visualization` API. This represents the frontend configuration for a query
# result (e.g. custom fields, filters, settings, etc.) We are not specifying a
# detailed schema for this object yet, but we should.
QUERY_RESULT_SPEC_SCHEMA = fields.Custom(
    fields.Any(),
    description='The query result spec object describing a query result and its configuration to be added to a dashboard.',
)

ADD_QUERY_TO_DASHBOARD_SCHEMA = fields.Object(
    properties={
        'activeViewType': fields.String(
            description='The currently active view type when the query was saved',
            nullable=False,
        ),
        'queryResultSpec': QUERY_RESULT_SPEC_SCHEMA,
        'querySelections': SELECTIONS_SCHEMA,
    },
    description='The request object to add a query to a dashboard',
)

# The schema for the dashboard's specification. Because the specification is stored in the database
# as a text value, we must serialize and deserialize as part of retrieval / update.
# TODO(vedant) - We can actually define the entire Dashboard Schema here.
# Determine if it's necessary.
# HACK(vedant) - This is actually a hack. The `io=w` signals to Potion that this is a write-only
# field when it is infact a readable field as well. The reason that we mark it as a write-only
# field is to prevent it from being shown in the `GET` call to the API root. We only want this
# field to be shown in the resource-specific `GET` call. The correct solution is to build this
# behaviour into Flask-Potion (configurable fields depending on query view / resource view).
SPECIFICATION_SCHEMA = fields.Custom(
    fields.Any(),
    description='The JSON specification that is used to render the dashboard.',
    default=EMPTY_SPECIFICATION_AS_JSON,
    converter=format_and_upgrade_specification,
    formatter=format_and_upgrade_specification,
    io='w',
)

NULLABLE_SLUG_SCHEMA = fields.String(
    description='The short name that is used to compute the URL for the UI representation '
    'of this dashboard. If it is not specified during creation, it will be '
    'inferred from the title embedded in the dashboard specification.',
    pattern=DASHBOARD_SLUG_PATTERN,
    nullable=True,
)

TITLE_SCHEMA = fields.Custom(
    fields.String(), attribute='specification', formatter=get_dashboard_title, io='r'
)

DESCRIPTION_SCHEMA = fields.String(
    description='A short description of the dashboard.', nullable=True
)

AUTHOR_USERNAME_SCHEMA = fields.Custom(
    fields.Email(pattern=EMAIL_PATTERN, nullable=True),
    description='The author\'s username. If not visible to the user, this will be null.',
    attribute='author_username',
    io='r',
)

AUTHOR_URI_SCHEMA = fields.ItemUri(
    'web.server.api.user_api_models.UserResource', attribute='author_id'
)

RESOURCE_URI_SCHEMA = fields.ItemUri(
    'web.server.api.permission_api_models.BackendResource', attribute='resource_id'
)

CREATED_SCHEMA = fields.DateTimeString(
    description='When the dashboard was created.', attribute='created', io='r'
)

LAST_MODIFIED_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was modified.',
    attribute='last_modified_real',
    io='r',
)

IS_OFFICIAL_SCHEMA = fields.Boolean(
    attribute='is_official',
    description='Indicates whether or not an administrator has flagged the '
    'dashboard as "official" or not.',
    io='r',
)

IS_FAVORITE_SCHEMA = fields.Boolean(
    description='Indicates whether or not the dashboard has been favorited by the current user.',
    attribute='is_favorite',
    io='r',
)

LAST_ACCESSED_BY_USER_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was accessed (if ever) by the current user.',
    nullable=True,
    attribute='last_accessed_by_user',
    io='r',
)

LAST_MODIFIED_BY_USER_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was edited (if ever) by the current user.',
    nullable=True,
    attribute='last_modified_by_user',
    io='r',
)

TOTAL_VIEWS_BY_USER_SCHEMA = fields.Integer(
    description='The total number of times the current user has viewed the dashboard.',
    minimum=0,
    attribute='total_views_by_user',
    io='r',
)

TOTAL_VIEWS_SCHEMA = fields.Integer(
    description='The total number of times the dashboard has been viewed.',
    minimum=0,
    attribute='total_views_real',
    io='r',
)

DASHBOARD_BASE_FIELDS = {
    '$uri': fields.ItemUri(
        'web.server.api.dashboard_api_models.DashboardResource', attribute='resource_id'
    ),
    'title': TITLE_SCHEMA,
    'slug': NULLABLE_SLUG_SCHEMA,
    'description': DESCRIPTION_SCHEMA,
    'author': AUTHOR_URI_SCHEMA,
    'authorUsername': AUTHOR_USERNAME_SCHEMA,
    'resource': RESOURCE_URI_SCHEMA,
    'created': CREATED_SCHEMA,
    'isOfficial': IS_OFFICIAL_SCHEMA,
}

DASHBOARD_METADATA_FIELDS = {
    'isFavorite': IS_FAVORITE_SCHEMA,
    'lastAccessedByCurrentUser': LAST_ACCESSED_BY_USER_SCHEMA,
    'lastModified': LAST_MODIFIED_SCHEMA,
    'lastModifiedByCurrentUser': LAST_MODIFIED_BY_USER_SCHEMA,
    'totalViews': TOTAL_VIEWS_SCHEMA,
    'totalViewsByUser': TOTAL_VIEWS_BY_USER_SCHEMA,
}

DASHBOARD_SIMPLE_FIELDS = {}
DASHBOARD_SIMPLE_FIELDS.update(DASHBOARD_BASE_FIELDS)
DASHBOARD_SIMPLE_FIELDS.update(DASHBOARD_METADATA_FIELDS)

# Not the prettiest solution to getting the URI to appear in the overriden GET/PATCH Schema but it
# works for now. One option would be to override the ModelResource Meta and add a new property
# (e.g. 'single_view_fields') which would only serialize certain fields if viewing a single resource
# item as opposed to a list.
# TODO(vedant) - Figure out how to do this in a better way.
DASHBOARD_DETAILED_FIELDS = {'specification': SPECIFICATION_SCHEMA}
DASHBOARD_DETAILED_FIELDS.update(DASHBOARD_SIMPLE_FIELDS)

DETAILED_DASHBOARD_SCHEMA = alchemy_fields.InlineModel(
    DASHBOARD_DETAILED_FIELDS, model=Dashboard, description='The dashboard model.'
)

USER_URI_SCHEMA = fields.ItemUri('web.server.api.user_api_models.UserResource')

HISTORY_CHANGE_SCHEMA = generate_history_record_schema(
    fields.ItemUri(
        'web.server.api.dashboard_api_models.DashboardResource', attribute='object_id'
    ),
    'dashboard',
)

DASHBOARD_CHANGES_SCHEMA = fields.List(
    HISTORY_CHANGE_SCHEMA, description='Dashboard history records'
)

# Schemas for properties that are never sent by the user but must be stubbed
# out to make flask potion happy.
UNUSED_LAST_MODIFIED_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was modified.',
    attribute='last_modified',
    io='r',
)

UNUSED_TOTAL_VIEWS_SCHEMA = fields.Integer(
    description='The total number of times the dashboard has been viewed.',
    minimum=0,
    attribute='total_views',
    io='r',
)


class DashboardResource(PrincipalResource):
    '''The potion class for performing CRUD operations on the `Dashboard` class.
    '''

    resource = Relation('resource', io='r')
    author = Relation('user', io='r')

    class Meta(object):
        manager = principals(DashboardManager)
        model = Dashboard
        natural_key = 'slug'
        excluded_fields = ('id',)
        id_attribute = 'resource_id'

        permissions = {'read': 'view_resource'}

        filters = {
            'slug': True,
            'title': True,
            'created': True,
            'author': {'eq': UserFilter, None: UserFilter},
            'isOfficial': True,
        }

    class Schema(object):
        title = TITLE_SCHEMA

        slug = NULLABLE_SLUG_SCHEMA

        description = DESCRIPTION_SCHEMA

        specification = SPECIFICATION_SCHEMA

        authorUsername = AUTHOR_USERNAME_SCHEMA

        author = AUTHOR_URI_SCHEMA

        resource = RESOURCE_URI_SCHEMA

        created = CREATED_SCHEMA

        isOfficial = IS_OFFICIAL_SCHEMA

        # NOTE(stephen): These fields are now pulled **from metadata** not from
        # the Dashboard model directly. They are only represented here to make
        # flask potion happy EVEN THOUGH THEY WILL NEVER EVER BE SENT BY THE
        # CLIENT, FLASK POTION STILL COMPLAINS.
        lastModified = UNUSED_LAST_MODIFIED_SCHEMA
        totalViews = UNUSED_TOTAL_VIEWS_SCHEMA

    # HACK(stephen): Attaching dashboard metadata to the base dashboard model
    # response is like fitting a square peg into a round hole. To add that
    # information in ways that Flask-Potion would naturally work causes us to
    # issue a huge number of queries per dashboard (previously 14 queries per
    # dashboard with a naive implementation). This query encapsulates all the
    # information needed for the dashboard response into a single query.
    # TODO(stephen): If we have to write workarounds like this, it probably
    # means we shouldn't be jamming too much information into a single API.
    def _attach_metadata_to_query(self, query):
        # NOTE(stephen): I don't think a transaction is necessary for this
        # read only query, but it is an easy way to access the session.
        with Transaction() as transaction:
            session = transaction._session
            subquery = DashboardUserMetadata.summary_by_dashboard_for_user(
                session, current_user.id
            ).subquery()
            return (
                query
                # Join in the summarized metadata for each dashboard.
                .outerjoin(subquery, Dashboard.id == subquery.c.dashboard_id)
                # Attach user info so we can extract the author username.
                .outerjoin(User, Dashboard.author_id == User.id)
                # Make sure all the metadata columns are included.
                .add_columns(subquery)
                # Also include all dashboard columns since otherwise a new query
                # will be issued EACH TIME we access a dashboard in the query
                # result.
                .add_columns(Dashboard.__table__)
                # Manually set up author_username since hybrid properties weren't
                # transferring.
                .add_columns(User.username.label('author_username'))
            )

    # HACK(stephen): To ensure endpoints that return a single dashboard also
    # include the appropriate metadata, we must join in the dashboard metadata
    # to our single dashboard query.
    def _get_single_dashboard_with_metadata(self, resource_id):
        # NOTE(stephen): The resource_id being filtered on here is **not**
        # Dashboard.id. This is because we use the `resource_id` column for
        # lookups and reference.
        query = self.manager._query().filter(self.manager.id_column == resource_id)
        return self._attach_metadata_to_query(query).one()

    # pylint: disable=R0201
    # pylint: disable=E1101
    # Flask Potion does not allow class methods.

    # Override the default "get all dashboards" route to augment the response
    # with dashboard specific metadata.
    @Route.GET(
        '',
        rel='instances',
        title='Something',
        description='Something',
        schema=Instances(),
        response_schema=fields.Array(fields.Object(DASHBOARD_SIMPLE_FIELDS)),
    )
    def get_instances(self, page, per_page, where, sort):
        base_query = self.manager.instances(where, sort)

        # NOTE(stephen): I'm not sure why this wouldn't exist, but I think it
        # only happens when there are no dashboards in the DB.
        if not base_query:
            return []

        return self._attach_metadata_to_query(base_query).paginate(page, per_page).items

    @Route.POST(
        '/upgrade',
        title='Upgrade Dashboard Specification',
        description='Upgrades the provided dashboard specification to the '
        'latest schema version supported by the server.',
        schema=fields.Any(),
        rel='upgrade',
    )
    def upgrade_dashboard(self, dashboard_specification):
        # The validation is being done in the conversion defined by SPECIFICATION_SCHEMA. If there
        # are any errors, they will be thrown as an exception to the client. No action needs to be
        # taken here.
        return format_and_upgrade_specification(dashboard_specification)

    @ItemRoute.POST(
        '/visualization',
        title='Add Simple Query Visualization',
        description='Adds an item from Simple Query Tool to the dashboard.',
        schema=ADD_QUERY_TO_DASHBOARD_SCHEMA,
        response_schema=DETAILED_DASHBOARD_SCHEMA,
        rel='addVisualization',
    )
    def add_visualization(self, dashboard, request):
        resource_id = dashboard.resource.id
        with AuthorizedOperation('edit_resource', 'dashboard', resource_id):
            _add_visualization(dashboard, request, False)
            track_dashboard_access(dashboard.id, True)
            return self._get_single_dashboard_with_metadata(resource_id)

    @ItemRoute.POST(
        '/visualization/advanced',
        title='Add Advanced Query Visualization',
        description='Adds an item from Advanced Query Tool to the dashboard.',
        schema=ADD_QUERY_TO_DASHBOARD_SCHEMA,
        response_schema=DETAILED_DASHBOARD_SCHEMA,
        rel='addAdvancedVisualization',
    )
    def add_advanced_visualization(self, dashboard, request):
        resource_id = dashboard.resource.id
        with AuthorizedOperation('edit_resource', 'dashboard', resource_id):
            _add_visualization(dashboard, request, True)
            track_dashboard_access(dashboard.id, True)
            return self._get_single_dashboard_with_metadata(resource_id)

    @ItemRoute.POST(
        '/transfer',
        title='Transfer Ownership',
        description='Transfers the ownership of this dashboard from the current'
        'owner to the one specified. ',
        schema=USER_URI_SCHEMA,
    )
    def transfer_ownership(self, dashboard, new_author):
        with AuthorizedOperation(
            'update_users', 'dashboard', dashboard.resource_id
        ), AuthorizedOperation('view_resource', 'user', dashboard.author.id):
            new_author = lookup_author(author_id=new_author)
            api_transfer_dashboard_ownership(dashboard, new_author)
            return None, NO_CONTENT

    @ItemRoute.POST(
        '/transfer/username',
        title='Transfer Ownership',
        description='Transfers the ownership of this dashboard from the current'
        'owner to the one specified. ',
        schema=USERNAME_SCHEMA,
    )
    def transfer_ownership_by_username(self, dashboard, new_author):
        with AuthorizedOperation(
            'update_users', 'dashboard', dashboard.resource_id
        ), AuthorizedOperation('view_resource', 'user', dashboard.author.id):
            new_author = lookup_author(author_username=new_author)
            api_transfer_dashboard_ownership(dashboard, new_author)
            return None, NO_CONTENT

    @Route.POST(
        '/transfer',
        title='Transfer Ownership',
        description='Transfers the ownership of ALL dashboards from one user '
        'to another.',
        schema=fields.Object(
            {'sourceAuthor': USER_URI_SCHEMA, 'targetAuthor': USER_URI_SCHEMA}
        ),
    )
    @authorization_required('update_users', 'dashboard')
    def transfer_bulk_ownership(self, request):
        source_author = lookup_author(author_id=request['sourceAuthor'])
        target_author = lookup_author(author_id=request['targetAuthor'])
        api_bulk_transfer_dashboard_ownership(source_author, target_author)
        return None, NO_CONTENT

    @Route.POST(
        '/transfer/username',
        title='Transfer Ownership',
        description='Transfers the ownership of ALL dashboards from one user '
        'to another.',
        schema=fields.Object(
            {'sourceAuthor': USERNAME_SCHEMA, 'targetAuthor': USERNAME_SCHEMA}
        ),
    )
    @authorization_required('update_users', 'dashboard')
    def transfer_bulk_ownership_by_username(self, request):
        source_author = lookup_author(author_username=request['sourceAuthor'])
        target_author = lookup_author(author_username=request['targetAuthor'])
        api_bulk_transfer_dashboard_ownership(source_author, target_author)
        return None, NO_CONTENT

    @ItemRoute.POST(
        '/official',
        title='Update Dashboard \'official\' flag',
        description='Marks a Dashboard as official or not.',
        schema=fields.Boolean(
            description='The updated value of the "isOfficial" flag for the '
            'dashboard.'
        ),
    )
    @authorization_required('publish_resource', 'dashboard')
    def set_official(self, dashboard, is_official):
        self.manager.update(dashboard, {'is_official': is_official})
        return None, NO_CONTENT

    @ItemRoute.POST(
        '/favorite',
        title='Update Dashboard \'favorite\' flag',
        description='Marks a Dashboard as a user favorite or not.',
        schema=fields.Boolean(
            description='The updated value of the "isFavorite" flag for the '
            'dashboard.'
        ),
    )
    def set_favorite(self, dashboard, is_favorite):
        with AuthorizedOperation(
            'view_resource', 'dashboard', dashboard.id
        ), Transaction() as transaction:
            metadata = get_or_create_metadata(transaction, dashboard.id)
            metadata.is_favorite = is_favorite
            transaction.add_or_update(metadata)

        return None, NO_CONTENT

    # NOTE(vedant): Why are we overriding the default potion route for GET <{}:id> and
    # PATCH <{}:id>?
    #
    # We want to only display the dashboard specification when an individual dashboard is
    # requested. To do this, we have to tailor the response schema to include the specification
    # field which would otherwise NOT be included in the default Schema specified in the `Schema`
    # subclass of `DashboardResource`.
    #
    # The rationale for only display the complete dashboard specification is that specifications
    # have a tendency to be very large and we don't want to send a lot of useless data over the
    # wire unless it is specifically asked for by the client. It is also very unlikely that a
    # client will ever be loading more than one dashboard specification at a given time.
    @Route.GET(
        lambda r: '/<{}:id>'.format(r.meta.id_converter),
        rel='self',
        attribute='instance',
        response_schema=DETAILED_DASHBOARD_SCHEMA,
    )
    def read(self, id):
        with Transaction() as transaction:
            dashboard = super(DashboardResource, self).read(id)
            dashboard.total_views += 1
            track_dashboard_access(dashboard.id)
            dashboard = transaction.add_or_update(dashboard, flush=True)
        return self._get_single_dashboard_with_metadata(id)

    @Route.PATCH(
        lambda r: '/<{}:id>'.format(r.meta.id_converter),
        rel='update',
        schema=fields.Inline('self', patchable=True),
        response_schema=DETAILED_DASHBOARD_SCHEMA,
    )
    def update(self, properties, id):
        dashboard = super(DashboardResource, self).update(properties, id)
        track_dashboard_access(dashboard.id, edited=True)
        return self._get_single_dashboard_with_metadata(id)

    @ItemRoute.GET(
        '/history',
        title='Dashboard Update History',
        schema=Instances(),
        description='Gets dashboard history data',
        rel='getDashboardHistory',
        response_schema=DASHBOARD_CHANGES_SCHEMA,
    )
    # pylint: disable=W0613
    # Method signature requires where and sort params
    def get_history(self, dashboard, page, per_page, where, sort):
        records = []
        with Transaction() as transaction:
            records = (
                transaction.find_all_by_fields(
                    HistoryRecord,
                    {'object_id': dashboard.resource_id, 'object_type': self.meta.name},
                )
                .paginate(page, per_page)
                .items
            )
        return records


def track_dashboard_access(dashboard_id, edited=False):
    with Transaction() as transaction:
        metadata = get_or_create_metadata(transaction, dashboard_id)
        now = datetime.now()
        metadata.last_viewed = now
        metadata.views_by_user += 1
        if edited:
            metadata.last_edited = now
        transaction.add_or_update(metadata)


# pylint: disable=W0613
# Suppressing this warning because this is the method signature for signal handlers.
@after_create.connect_via(DashboardResource)
def send_email_after_create(sender, item):
    dashboard_link = url_for('dashboard.grid_dashboard', name=item.slug, _external=True)
    message = current_app.email_renderer.create_new_dashboard_message(
        item.author, current_app.zen_config.general.DEPLOYMENT_FULL_NAME, dashboard_link
    )
    try:
        g.request_logger.info(
            'Sending new dashboard notification email to: \'%s\'', item.author_username
        )
        current_app.notification_service.send_email(message)
    except NotificationError:
        g.request_logger.error(
            'Failed to send new dashboard notification email to: \'%s\'',
            item.author_username,
        )


@before_update.connect_via(DashboardResource)
def track_dashboard_changes(sender, item, changes):
    with Transaction() as transaction:
        dashboard_changes = as_dictionary(item)
        updated_changes = {}

        for key, value in list(dashboard_changes.items()):
            if isinstance(value, datetime):
                # datetime is not directly JSON serializable. Thus, we format
                # it as an ISO8601 string.
                updated_changes[key] = value.isoformat()
            else:
                updated_changes[key] = value

        record = HistoryRecord(
            object_type=sender.meta.name,
            object_id=item.resource_id,
            changes=updated_changes,
            user_id=current_user.id,
        )
        transaction.add_or_update(record)


@after_create.connect_via(DashboardResource)
def generate_metadata_after_create(sender, item):
    with Transaction() as transaction:
        metadata = get_or_create_metadata(transaction, item.id)
        now = datetime.now()
        metadata.last_viewed = now
        metadata.last_edited = now
        metadata.views_by_user = 1
        item.total_views += 1
        transaction.add_or_update(metadata)
        transaction.add_or_update(item)


RESOURCE_TYPES = [DashboardResource]
